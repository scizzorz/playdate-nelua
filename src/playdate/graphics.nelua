global LCD_COLUMNS <const> = 400
global LCD_ROWS <const> = 240
global LCD_ROWSIZE <const> = 52

--[[ enums ]]
-- LCDBitmapDrawMode
global DrawMode: type <cimport "LCDBitmapDrawMode", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global DrawMode.Copy: DrawMode <cimport "kDrawModeCopy", nodecl, cinclude "pd_api.h">
global DrawMode.WhiteTransparent: DrawMode <cimport "kDrawModeWhiteTransparent", nodecl, cinclude "pd_api.h">
global DrawMode.BlackTransparent: DrawMode <cimport "kDrawModeBlackTransparent", nodecl, cinclude "pd_api.h">
global DrawMode.FillWhite: DrawMode <cimport "kDrawModeFillWhite", nodecl, cinclude "pd_api.h">
global DrawMode.FillBlack: DrawMode <cimport "kDrawModeFillBlack", nodecl, cinclude "pd_api.h">
global DrawMode.XOR: DrawMode <cimport "kDrawModeXOR", nodecl, cinclude "pd_api.h">
global DrawMode.NXOR: DrawMode <cimport "kDrawModeNXOR", nodecl, cinclude "pd_api.h">
global DrawMode.Inverted: DrawMode <cimport "kDrawModeInverted", nodecl, cinclude "pd_api.h">

-- LCDBitmapFlip
global Flip: type <cimport "LCDBitmapFlip", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global Flip.None: Flip <cimport "kBitmapUnflipped", nodecl, cinclude "pd_api.h">
global Flip.X: Flip <cimport "kBitmapFlippedX", nodecl, cinclude "pd_api.h">
global Flip.Y: Flip <cimport "kBitmapFlippedY", nodecl, cinclude "pd_api.h">
global Flip.XY: Flip <cimport "kBitmapFlippedXY", nodecl, cinclude "pd_api.h">

-- LCDSolidColor
global Color: type <cimport "LCDSolidColor", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global Color.Black: Color <cimport "kColorBlack", nodecl, cinclude "pd_api.h">
global Color.White: Color <cimport "kColorWhite", nodecl, cinclude "pd_api.h">
global Color.Clear: Color <cimport "kColorClear", nodecl, cinclude "pd_api.h">
global Color.XOR: Color <cimport "kColorXOR", nodecl, cinclude "pd_api.h">

-- LCDLineCapStyle
global LineCapStyle: type <cimport "LCDLineCapStyle", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global LineCapStyle.Butt: LineCapStyle <cimport "kLineCapStyleButt", nodecl, cinclude "pd_api.h">
global LineCapStyle.Square: LineCapStyle <cimport "kLineCapStyleSquare", nodecl, cinclude "pd_api.h">
global LineCapStyle.Round: LineCapStyle <cimport "kLineCapStyleRound", nodecl, cinclude "pd_api.h">

-- LCDFontLanguage
global FontLanguage: type <cimport "LCDFontLanguage", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global FontLanguage.English: FontLanguage <cimport "kFontLanguageEnglish", nodecl, cinclude "pd_api.h">
global FontLanguage.Japanese: FontLanguage <cimport "kFontLanguageJapanese", nodecl, cinclude "pd_api.h">
global FontLanguage.Unknown: FontLanguage <cimport "kFontLanguageUnknown", nodecl, cinclude "pd_api.h">

-- PDStringEncoding
global StringEncoding: type <cimport "PDStringEncoding", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global StringEncoding.ASCII: StringEncoding <cimport "kASCIIEncoding", nodecl, cinclude "pd_api.h">
global StringEncoding.UTF8: StringEncoding <cimport "kUTF8Encoding", nodecl, cinclude "pd_api.h">
global StringEncoding.LE16bit: StringEncoding <cimport "k16BitLEEncoding", nodecl, cinclude "pd_api.h">

-- PDPolygonFillRule
global PolygonFillRule: type <cimport "PDPolygonFillRule", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global PolygonFillRule.FillNonZero: PolygonFillRule <cimport "kPolygonFillNonZero", nodecl, cinclude "pd_api.h">
global PolygonFillRule.FillEvenOdd: PolygonFillRule <cimport "kPolygonFillEvenOdd", nodecl, cinclude "pd_api.h">

-- PDTextWrappingMode
global TextWrappingMode: type <cimport "PDTextWrappingMode", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global TextWrappingMode.Clip: TextWrappingMode <cimport "kWrapClip", nodecl, cinclude "pd_api.h">
global TextWrappingMode.Character: TextWrappingMode <cimport "kWrapCharacter", nodecl, cinclude "pd_api.h">
global TextWrappingMode.Word: TextWrappingMode <cimport "kWrapWord", nodecl, cinclude "pd_api.h">

-- PDTextAlignment
global TextAlignment: type <cimport "PDTextAlignment", nodecl, cinclude "pd_api.h"> = @enum {
  UNUSED = 0, -- Nelua doesn't allow an empty enum, but we inject the values below.
}
global TextAlignment.Left: TextAlignment <cimport "kAlignTextLeft", nodecl, cinclude "pd_api.h">
global TextAlignment.Center: TextAlignment <cimport "kAlignTextCenter", nodecl, cinclude "pd_api.h">
global TextAlignment.Right: TextAlignment <cimport "kAlignTextRight", nodecl, cinclude "pd_api.h">

--[[ type aliases ]]
global Pattern: type = @[16]uint8
global ColorOrPattern: type = @usize

--[[ opaque types ]]
global FilePlayer: type <cimport, ctypedef, cinclude "pd_api.h"> = @record {}
global HTTPConnection: type <cimport, ctypedef, cinclude "pd_api.h"> = @record {}
global LCDBitmap: type <cimport "LCDBitmap", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDBitmapTable: type <cimport "LCDBitmapTable", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDFont: type <cimport "LCDFont", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDFontData: type <cimport "LCDFontData", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDFontGlyph: type <cimport "LCDFontGlyph", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDFontPage: type <cimport "LCDFontPage", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDStreamPlayer: type <cimport "LCDStreamPlayer", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDTileMap: type <cimport "LCDTileMap", ctypedef, cinclude "pd_api.h"> = @record {}
global LCDVideoPlayer: type <cimport "LCDVideoPlayer", ctypedef, cinclude "pd_api.h"> = @record {}
global TCPConnection: type <cimport, ctypedef, cinclude "pd_api.h"> = @record {}

--[[ structs ]]
-- LCDRect
global LCDRect: type <cimport, nodecl, cinclude "pd_api.h"> = @record {
  left: cint,
  right: cint, -- not inclusive
  top: cint,
  bottom: cint, -- not inclusive
}

--[[ graphics API ]]
-- playdate_video
global PlaydateVideo: type <cimport "playdate_video", ctypedef, cinclude "pd_api.h"> = @record {
  loadVideo: function(path: cstring): *LCDVideoPlayer,
  freePlayer: function(p: *LCDVideoPlayer),
  setContext: function(p: *LCDVideoPlayer, context: *LCDBitmap): cint,
  useScreenContext: function(p: *LCDVideoPlayer),
  renderFrame: function(p: *LCDVideoPlayer, n: cint): cint,
  getError: function(p: *LCDVideoPlayer): cstring,
  getInfo: function(p: *LCDVideoPlayer, outWidth: *cint, outHeight: *cint, outFrameRate: *float32, outFrameCount: *cint, outCurrentFrame: *cint),
  getContext: function(p: *LCDVideoPlayer): *LCDBitmap,
}

-- playdate_videostream
global PlaydateVideoStream: type <cimport "playdate_videostream", ctypedef, cinclude "pd_api.h"> = @record {
  newPlayer: function(): *LCDStreamPlayer,
  freePlayer: function(p: *LCDStreamPlayer),

  setBufferSize: function(p: *LCDStreamPlayer, video: cint, audio: cint),

  setFile: function(p: *LCDStreamPlayer, file: *File),
  setHTTPConnection: function(p: *LCDStreamPlayer, conn: *HTTPConnection),

  getFilePlayer: function(p: *LCDStreamPlayer): *FilePlayer,
  getVideoPlayer: function(p: *LCDStreamPlayer): *LCDVideoPlayer,

  setContext: function(p: *LCDStreamPlayer, context: *LCDBitmap): cint,
  getContext: function(p: *LCDStreamPlayer): *LCDBitmap,

  -- returns true if it drew a frame, else false
  update: function(p: *LCDStreamPlayer): boolean,

  getBufferedFrameCount: function(p: *LCDStreamPlayer): cint,

  getBytesRead: function(p: *LCDStreamPlayer): uint32,

  -- 3.0
  setTCPConnection: function(p: *LCDStreamPlayer, conn: *TCPConnection),
}

-- playdate_tilemap
global PlaydateTilemap: type <cimport "playdate_tilemap", ctypedef, cinclude "pd_api.h"> = @record {
  newTilemap: function(): *LCDTileMap,
  freeTilemap: function(m: *LCDTileMap),

  setImageTable: function(m: *LCDTileMap, table: *LCDBitmapTable),
  getImageTable: function(m: *LCDTileMap): *LCDBitmapTable,

  setSize: function(m: *LCDTileMap, tilesWide: cint, tilesHigh: cint),
  getSize: function(m: *LCDTileMap, tilesWide: *cint, tilesHigh: *cint),
  getPixelSize: function(m: *LCDTileMap, outWidth: *uint32, outHeight: *uint32),

  setTiles: function(m: *LCDTileMap, indexes: *uint16, count: cint, rowwidth: cint),

  setTileAtPosition: function(m: *LCDTileMap, x: cint, y: cint, idx: uint16),
  getTileAtPosition: function(m: *LCDTileMap, x: cint, y: cint): cint,

  drawAtPoint: function(m: *LCDTileMap, x: float32, y: float32),
}

-- playdate_graphics
global PlaydateGraphics: type <cimport "playdate_graphics", ctypedef, cinclude "pd_api.h"> = @record {
  video: *PlaydateVideo,

  -- Drawing Functions
  clear: function(color: ColorOrPattern),
  setBackgroundColor: function(color: Color),
  setStencil: function(stencil: *LCDBitmap), -- deprecated in favor of setStencilImage, which adds a "tile" flag
  setDrawMode: function(mode: DrawMode): DrawMode,
  setDrawOffset: function(dx: cint, dy: cint),
  setClipRect: function(x: cint, y: cint, width: cint, height: cint),
  clearClipRect: function(),
  setLineCapStyle: function(endCapStyle: LineCapStyle),
  setFont: function(font: *LCDFont),
  setTextTracking: function(tracking: cint),
  pushContext: function(target: *LCDBitmap),
  popContext: function(),

  drawBitmap: function(bitmap: *LCDBitmap, x: cint, y: cint, flip: Flip),
  tileBitmap: function(bitmap: *LCDBitmap, x: cint, y: cint, width: cint, height: cint, flip: Flip),
  drawLine: function(x1: cint, y1: cint, x2: cint, y2: cint, width: cint, color: ColorOrPattern),
  fillTriangle: function(x1: cint, y1: cint, x2: cint, y2: cint, x3: cint, y3: cint, color: ColorOrPattern),
  drawRect: function(x: cint, y: cint, width: cint, height: cint, color: ColorOrPattern),
  fillRect: function(x: cint, y: cint, width: cint, height: cint, color: ColorOrPattern),
  drawEllipse: function(x: cint, y: cint, width: cint, height: cint, lineWidth: cint, startAngle: float32, endAngle: float32, color: ColorOrPattern), -- stroked inside the rect
  fillEllipse: function(x: cint, y: cint, width: cint, height: cint, startAngle: float32, endAngle: float32, color: ColorOrPattern),
  drawScaledBitmap: function(bitmap: *LCDBitmap, x: cint, y: cint, xscale: float32, yscale: float32),
  drawText: function(text: pointer, len: csize, encoding: StringEncoding, x: cint, y: cint): cint,

  -- LCDBitmap
  newBitmap: function(width: cint, height: cint, bgcolor: ColorOrPattern): *LCDBitmap,
  freeBitmap: function(unnamed0: *LCDBitmap),
  loadBitmap: function(path: cstring, outerr: *cstring): *LCDBitmap,
  copyBitmap: function(bitmap: *LCDBitmap): *LCDBitmap,
  loadIntoBitmap: function(path: cstring, bitmap: *LCDBitmap, outerr: *cstring),
  getBitmapData: function(bitmap: *LCDBitmap, width: *cint, height: *cint, rowbytes: *cint, mask: **uint8, data: **uint8),
  clearBitmap: function(bitmap: *LCDBitmap, bgcolor: ColorOrPattern),
  rotatedBitmap: function(bitmap: *LCDBitmap, rotation: float32, xscale: float32, yscale: float32, allocedSize: *cint): *LCDBitmap,

  -- LCDBitmapTable
  newBitmapTable: function(count: cint, width: cint, height: cint): *LCDBitmapTable,
  freeBitmapTable: function(table: *LCDBitmapTable),
  loadBitmapTable: function(path: cstring, outerr: *cstring): *LCDBitmapTable,
  loadIntoBitmapTable: function(path: cstring, table: *LCDBitmapTable, outerr: *cstring),
  getTableBitmap: function(table: *LCDBitmapTable, idx: cint): *LCDBitmap,

  -- LCDFont
  loadFont: function(path: cstring, outErr: *cstring): *LCDFont,
  getFontPage: function(font: *LCDFont, c: uint32): *LCDFontPage,
  getPageGlyph: function(page: *LCDFontPage, c: uint32, bitmap: **LCDBitmap, advance: *cint): *LCDFontGlyph,
  getGlyphKerning: function(glyph: *LCDFontGlyph, glyphcode: uint32, nextcode: uint32): cint,
  getTextWidth: function(font: *LCDFont, text: pointer, len: csize, encoding: StringEncoding, tracking: cint): cint,

  -- raw framebuffer access
  getFrame: function(): *uint8, -- row stride = LCD_ROWSIZE
  getDisplayFrame: function(): *uint8, -- row stride = LCD_ROWSIZE
  getDebugBitmap: function(): *LCDBitmap, -- valid in simulator only, function is NULL on device
  copyFrameBufferBitmap: function(): *LCDBitmap,
  markUpdatedRows: function(start: cint, end_: cint),
  display: function(),

  -- misc util.
  setColorToPattern: function(color: *ColorOrPattern, bitmap: *LCDBitmap, x: cint, y: cint),
  checkMaskCollision: function(bitmap1: *LCDBitmap, x1: cint, y1: cint, flip1: Flip, bitmap2: *LCDBitmap, x2: cint, y2: cint, flip2: Flip, rect: LCDRect): cint,

  -- 1.1
  setScreenClipRect: function(x: cint, y: cint, width: cint, height: cint),

  -- 1.1.1
  fillPolygon: function(nPoints: cint, coords: *cint, color: ColorOrPattern, fillrule: PolygonFillRule),
  getFontHeight: function(font: *LCDFont): uint8,

  -- 1.7
  getDisplayBufferBitmap: function(): *LCDBitmap,
  drawRotatedBitmap: function(bitmap: *LCDBitmap, x: cint, y: cint, rotation: float32, centerx: float32, centery: float32, xscale: float32, yscale: float32),
  setTextLeading: function(lineHeightAdustment: cint),

  -- 1.8
  setBitmapMask: function(bitmap: *LCDBitmap, mask: *LCDBitmap): cint,
  getBitmapMask: function(bitmap: *LCDBitmap): *LCDBitmap,

  -- 1.10
  setStencilImage: function(stencil: *LCDBitmap, tile: cint),

  -- 1.12
  makeFontFromData: function(data: *LCDFontData, wide: cint): *LCDFont,

  -- 2.1
  getTextTracking: function(): cint,

  -- 2.5
  setPixel: function(x: cint, y: cint, c: ColorOrPattern),
  getBitmapPixel: function(bitmap: *LCDBitmap, x: cint, y: cint): Color,
  getBitmapTableInfo: function(table: *LCDBitmapTable, count: *cint, width: *cint),

  -- 2.6
  drawTextInRect: function(text: pointer, len: csize, encoding: StringEncoding, x: cint, y: cint, width: cint, height: cint, wrap: TextWrappingMode, align: TextAlignment),

  -- 2.7
  getTextHeightForMaxWidth: function(font: *LCDFont, text: pointer, len: csize, maxwidth: cint, encoding: StringEncoding, wrap: TextWrappingMode, tracking: cint, extraLeading: cint): cint,
  drawRoundRect: function(x: cint, y: cint, width: cint, height: cint, radius: cint, lineWidth: cint, color: ColorOrPattern),
  fillRoundRect: function(x: cint, y: cint, width: cint, height: cint, radius: cint, color: ColorOrPattern),

  -- 3.0
  tilemap: *PlaydateTilemap,
  videostream: *PlaydateVideoStream,
}
