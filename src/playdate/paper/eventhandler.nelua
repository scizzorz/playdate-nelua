local PlaydateEventHandler: type = @record {
  -- system events
  init: function(self: *PlaydateEventHandler): void,
  init_lua: function(self: *PlaydateEventHandler): void,
  lock: function(self: *PlaydateEventHandler): void,
  unlock: function(self: *PlaydateEventHandler): void,
  pause: function(self: *PlaydateEventHandler): void,
  resume: function(self: *PlaydateEventHandler): void,
  terminate: function(self: *PlaydateEventHandler): void,
  low_power: function(self: *PlaydateEventHandler): void,
  key_pressed: function(self: *PlaydateEventHandler, key: uint32): void,
  key_released: function(self: *PlaydateEventHandler, key: uint32): void,
  mirror_started: function(self: *PlaydateEventHandler): void,
  mirror_ended: function(self: *PlaydateEventHandler): void,

  -- update callback
  update: function(self: *PlaydateEventHandler): void,

  -- button callbacks
  button_queue_size: integer,
  button_a_pressed: function(self: *PlaydateEventHandler): void,
  button_a_released: function(self: *PlaydateEventHandler): void,
  button_b_pressed: function(self: *PlaydateEventHandler): void,
  button_b_released: function(self: *PlaydateEventHandler): void,
  button_up_pressed: function(self: *PlaydateEventHandler): void,
  button_up_released: function(self: *PlaydateEventHandler): void,
  button_down_pressed: function(self: *PlaydateEventHandler): void,
  button_down_released: function(self: *PlaydateEventHandler): void,
  button_left_pressed: function(self: *PlaydateEventHandler): void,
  button_left_released: function(self: *PlaydateEventHandler): void,
  button_right_pressed: function(self: *PlaydateEventHandler): void,
  button_right_released: function(self: *PlaydateEventHandler): void,

  -- button states
  button_a_is_pressed: boolean,
  button_b_is_pressed: boolean,
  button_up_is_pressed: boolean,
  button_down_is_pressed: boolean,
  button_left_is_pressed: boolean,
  button_right_is_pressed: boolean,

  -- crank callbacks
  crank_docked: function(self: *PlaydateEventHandler): void,
  crank_undocked: function(self: *PlaydateEventHandler): void,

  -- crank states
  crank_is_docked: boolean,
}

global PlaydateEvents: PlaydateEventHandler = {}
PlaydateEvents.button_queue_size = 5

global Playdate: *PlaydateAPI

local initialized: boolean = false

local function updateCallback(self: pointer): cint
  -- crank docking callback
  local crank_is_docked = (Playdate.system.isCrankDocked() == 1)
  if crank_is_docked and not PlaydateEvents.crank_is_docked and PlaydateEvents.crank_docked ~= nilptr then
    PlaydateEvents:crank_docked()
  elseif not crank_is_docked and PlaydateEvents.crank_is_docked and PlaydateEvents.crank_undocked ~= nilptr then
    PlaydateEvents:crank_undocked()
  end
  PlaydateEvents.crank_is_docked = crank_is_docked

  PlaydateEvents:update()
  return 1
end

local function buttonCallback(button: Buttons, down: cint, when: uint32, userdata: pointer): cint
  local call: function(self: *PlaydateEventHandler) = nilptr
  if button == Buttons.A then
    if down == 1 then
      call = PlaydateEvents.button_a_pressed
      PlaydateEvents.button_a_is_pressed = true
    elseif down == 0 then
      call = PlaydateEvents.button_a_released
      PlaydateEvents.button_a_is_pressed = false
    end

  elseif button == Buttons.B then
    if down == 1 then
      call = PlaydateEvents.button_b_pressed
      PlaydateEvents.button_b_is_pressed = true
    elseif down == 0 then
      call = PlaydateEvents.button_b_released
      PlaydateEvents.button_b_is_pressed = false
    end

  elseif button == Buttons.Up then
    if down == 1 then
      call = PlaydateEvents.button_up_pressed
      PlaydateEvents.button_up_is_pressed = true
    elseif down == 0 then
      call = PlaydateEvents.button_up_released
      PlaydateEvents.button_up_is_pressed = false
    end

  elseif button == Buttons.Down then
    if down == 1 then
      call = PlaydateEvents.button_down_pressed
      PlaydateEvents.button_down_is_pressed = true
    elseif down == 0 then
      call = PlaydateEvents.button_down_released
      PlaydateEvents.button_down_is_pressed = false
    end

  elseif button == Buttons.Left then
    if down == 1 then
      call = PlaydateEvents.button_left_pressed
      PlaydateEvents.button_left_is_pressed = true
    elseif down == 0 then
      call = PlaydateEvents.button_left_released
      PlaydateEvents.button_left_is_pressed = false
    end

  elseif button == Buttons.Right then
    if down == 1 then
      call = PlaydateEvents.button_right_pressed
      PlaydateEvents.button_right_is_pressed = true
    elseif down == 0 then
      call = PlaydateEvents.button_right_released
      PlaydateEvents.button_right_is_pressed = false
    end
  end

  if call ~= nilptr then
    call(PlaydateEvents)
  end
  return 0
end

local function eventHandler(playdate: *PlaydateAPI, event: SystemEvent, arg: uint32): cint <cexport, codename "eventHandler">
  if not initialized then
    -- The Playdate SDK never calls main, but Nelua relies on main to
    -- initialize a lot of global variables. Main needs to be explicitly declared
    -- and called here so that it can be called manually from eventHandler.
    --
    -- This file needs to be transpiled with the `nogcentry` pragma defined
    -- because the default GC entrypoint assumes the entire program's lifecycle
    -- is contained within main, but for Playdate games, the entire program's
    -- lifecycle is actually _outside_ of main.
    --
    -- With the default GC entrypoint, the GC is initialized and then destroyed
    -- before the rest of the program even runs. By disabling it, the GC needs
    -- to be explicitly initialized here. It doesn't need to be destroyed
    -- because the Playdate OS does a complete reboot on exit anyway.
    local function main(argc: cint, argv: *cstring): cint <cimport, codename "main"> end
    local argc: cint = 0

    gc:init(&argc)
    main(argc, nilptr)

    initialized = true
    Playdate = playdate

    -- error: cannot assign a constant variable
    -- booooo
    -- print = playdate.system.logToConsole
    -- error = playdate.system.error
  end

  if event == SystemEvent.Init and PlaydateEvents.init ~= nilptr then
    if PlaydateEvents.update ~= nilptr then
      playdate.system.setUpdateCallback(updateCallback, nilptr)
      playdate.system.setButtonCallback(buttonCallback, nilptr, PlaydateEvents.button_queue_size)
    end
    PlaydateEvents:init()
  elseif event == SystemEvent.InitLua and PlaydateEvents.init_lua ~= nilptr then
    PlaydateEvents:init_lua()
  elseif event == SystemEvent.Lock and PlaydateEvents.lock ~= nilptr then
    PlaydateEvents:lock()
  elseif event == SystemEvent.Unlock and PlaydateEvents.unlock ~= nilptr then
    PlaydateEvents:unlock()
  elseif event == SystemEvent.Pause and PlaydateEvents.pause ~= nilptr then
    PlaydateEvents:pause()
  elseif event == SystemEvent.Resume and PlaydateEvents.resume ~= nilptr then
    PlaydateEvents:resume()
  elseif event == SystemEvent.Terminate and PlaydateEvents.terminate ~= nilptr then
    PlaydateEvents:terminate()
  elseif event == SystemEvent.LowPower and PlaydateEvents.low_power ~= nilptr then
    PlaydateEvents:low_power()
  elseif event == SystemEvent.KeyPressed and PlaydateEvents.key_pressed ~= nilptr then
    PlaydateEvents:key_pressed(arg)
  elseif event == SystemEvent.KeyReleased and PlaydateEvents.key_released ~= nilptr then
    PlaydateEvents:key_released(arg)
  elseif event == SystemEvent.MirrorStarted and PlaydateEvents.mirror_started ~= nilptr then
    PlaydateEvents:mirror_started()
  elseif event == SystemEvent.MirrorEnded and PlaydateEvents.mirror_ended ~= nilptr then
    PlaydateEvents:mirror_ended()
  end

  return 0
end
