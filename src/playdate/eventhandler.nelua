local PlaydateEventHandler: type = @record {
  -- system events
  init: function(self: *PlaydateEventHandler): void,
  init_lua: function(self: *PlaydateEventHandler): void,
  lock: function(self: *PlaydateEventHandler): void,
  unlock: function(self: *PlaydateEventHandler): void,
  pause: function(self: *PlaydateEventHandler): void,
  resume: function(self: *PlaydateEventHandler): void,
  terminate: function(self: *PlaydateEventHandler): void,
  low_power: function(self: *PlaydateEventHandler): void,
  key_pressed: function(self: *PlaydateEventHandler, key: uint32): void,
  key_released: function(self: *PlaydateEventHandler, key: uint32): void,
  mirror_started: function(self: *PlaydateEventHandler): void,
  mirror_ended: function(self: *PlaydateEventHandler): void,
  -- update callback
  update: function(self: *PlaydateEventHandler): void,
  -- button callbacks
  button_queue_size: integer,
  button_a_down: function(self: *PlaydateEventHandler): void,
  button_a_up: function(self: *PlaydateEventHandler): void,
  button_b_down: function(self: *PlaydateEventHandler): void,
  button_b_up: function(self: *PlaydateEventHandler): void,
  button_up_down: function(self: *PlaydateEventHandler): void,
  button_up_up: function(self: *PlaydateEventHandler): void,
  button_down_down: function(self: *PlaydateEventHandler): void,
  button_down_up: function(self: *PlaydateEventHandler): void,
  button_left_down: function(self: *PlaydateEventHandler): void,
  button_left_up: function(self: *PlaydateEventHandler): void,
  button_right_down: function(self: *PlaydateEventHandler): void,
  button_right_up: function(self: *PlaydateEventHandler): void,
}

global PlaydateEvents: PlaydateEventHandler = {}
PlaydateEvents.button_queue_size = 5

global Playdate: *PlaydateAPI

local initialized: boolean = false

local function updateCallback(self: pointer): cint
  PlaydateEvents:update()
  return 1
end

local function buttonCallback(button: Buttons, down: int64, when: uint32, userdata: pointer): cint
  local call: function(self: *PlaydateEventHandler) = nilptr
  if button == Buttons.A then
    if down == 1 then
      call = PlaydateEvents.button_a_down
    elseif down == 0 then
      call = PlaydateEvents.button_a_up
    end

  elseif button == Buttons.B then
    if down == 1 then
      call = PlaydateEvents.button_b_down
    elseif down == 0 then
      call = PlaydateEvents.button_b_up
    end

  elseif button == Buttons.Up then
    if down == 1 then
      call = PlaydateEvents.button_up_down
    elseif down == 0 then
      call = PlaydateEvents.button_up_up
    end

  elseif button == Buttons.Down then
    if down == 1 then
      call = PlaydateEvents.button_down_down
    elseif down == 0 then
      call = PlaydateEvents.button_down_up
    end

  elseif button == Buttons.Left then
    if down == 1 then
      call = PlaydateEvents.button_left_down
    elseif down == 0 then
      call = PlaydateEvents.button_left_up
    end

  elseif button == Buttons.Right then
    if down == 1 then
      call = PlaydateEvents.button_right_down
    elseif down == 0 then
      call = PlaydateEvents.button_right_up
    end
  end

  if call ~= nilptr then
    call(PlaydateEvents)
  end
  return 0
end

local function eventHandler(playdate: *PlaydateAPI, event: SystemEvent, arg: uint32): cint <cexport, codename "eventHandler">
  if not initialized then
    -- The Playdate SDK never calls main, but Nelua relies on main to
    -- initialize a lot of global variables. Main needs to be explicitly declared
    -- and called here so that it can be called manually from eventHandler.
    --
    -- This file needs to be transpiled with the `nogcentry` pragma defined
    -- because the default GC entrypoint assumes the entire program's lifecycle
    -- is contained within main, but for Playdate games, the entire program's
    -- lifecycle is actually _outside_ of main.
    --
    -- With the default GC entrypoint, the GC is initialized and then destroyed
    -- before the rest of the program even runs. By disabling it, the GC needs
    -- to be explicitly initialized here. It doesn't need to be destroyed
    -- because the Playdate OS does a complete reboot on exit anyway.
    local function main(argc: cint, argv: *cstring): cint <cimport, codename "main"> end
    local argc: cint = 0

    gc:init(&argc)
    main(argc, nilptr)

    initialized = true
    Playdate = playdate

    -- error: cannot assign a constant variable
    -- booooo
    -- print = playdate.system.logToConsole
    -- error = playdate.system.error
  end

  if event == SystemEvent.Init and PlaydateEvents.init ~= nilptr then
    if PlaydateEvents.update ~= nilptr then
      playdate.system.setUpdateCallback(updateCallback, nilptr)
      playdate.system.setButtonCallback(buttonCallback, nilptr, PlaydateEvents.button_queue_size)
    end
    PlaydateEvents:init()
  elseif event == SystemEvent.InitLua and PlaydateEvents.init_lua ~= nilptr then
    PlaydateEvents:init_lua()
  elseif event == SystemEvent.Lock and PlaydateEvents.lock ~= nilptr then
    PlaydateEvents:lock()
  elseif event == SystemEvent.Unlock and PlaydateEvents.unlock ~= nilptr then
    PlaydateEvents:unlock()
  elseif event == SystemEvent.Pause and PlaydateEvents.pause ~= nilptr then
    PlaydateEvents:pause()
  elseif event == SystemEvent.Resume and PlaydateEvents.resume ~= nilptr then
    PlaydateEvents:resume()
  elseif event == SystemEvent.Terminate and PlaydateEvents.terminate ~= nilptr then
    PlaydateEvents:terminate()
  elseif event == SystemEvent.LowPower and PlaydateEvents.low_power ~= nilptr then
    PlaydateEvents:low_power()
  elseif event == SystemEvent.KeyPressed and PlaydateEvents.key_pressed ~= nilptr then
    PlaydateEvents:key_pressed(arg)
  elseif event == SystemEvent.KeyReleased and PlaydateEvents.key_released ~= nilptr then
    PlaydateEvents:key_released(arg)
  elseif event == SystemEvent.MirrorStarted and PlaydateEvents.mirror_started ~= nilptr then
    PlaydateEvents:mirror_started()
  elseif event == SystemEvent.MirrorEnded and PlaydateEvents.mirror_ended ~= nilptr then
    PlaydateEvents:mirror_ended()
  end

  return 0
end
